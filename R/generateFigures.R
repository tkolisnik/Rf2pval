#' Generate Feature Importance Score-Rank Plot
#' This function generates a figure which shows the true observed data plotted against the permuted data, by rank. The intersection of the true data with the upper quartile is shown, which we recommend as a significance cutoff.
#' @param permutedvalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_permuted_fws function
#' @param quantiledata a tibble containing: featureRanks, mean, lower, upper, and observed as well as logmean, loglower, logupper, logobserved generated by the calculateQuantiles function
#' @param xlimitmin a numerical value for the minimum x value in the figure, default is 0
#' @param xlimitmax a numerical value for the maximum x value in the figure, default is 500 (this is effectively the total number of features to include)
#' @param ylimitmin a numerical value for the minimum y value in the figure, default is -10
#' @param ylimitmax a numerical value for the maximum y value in the figure, default is 0, but this will vary largely depending on your dataset, set it larger then narrow down
#' @param labelverticaladjust a numerical value specifying the vertical (y-axis) adjustment of the intersection with upper quartile label
#' @param labelhorizontaladjust a numerical value specifying the horizontal (x-axis) adjustment of the intersection with upper quartile label
#' @param indvPermScoresOn logical TRUE or FALSE, whethere or not to include the lines for each individual permutation feature importance score (shown in light blue)
#' @param logOn logical TRUE or FALSE, whether or not to use the log or unlogged data. Default to TRUE.
#' @return A plot of log feature importance score by feature rank showing the upper quartile intersection which we recommend to use for a cutoff.
#' @export
fiRankPlot<-function(permutedvalues,quantiledata,xlimitmin=0,xlimitmax=500,ylimitmin=-10,ylimitmax=0,labelverticaladjust=1.05,labelhorizontaladjust=1.05,indvPermScoresOn=TRUE, logOn=TRUE){
  if(logOn==TRUE){
  qdata<-quantiledata
  qdata2<- qdata %>% dplyr::filter(mean > 0) %>% dplyr::filter(is.finite(logobserved))
  permdata<-permutedvalues
  permdata2<-permdata %>% dplyr::filter(featureRank %in% qdata2$featureRank) %>% dplyr::filter(is.finite(LogfeatureImportance))
    ggplot2::ggplot(qdata2, aes(x = featureRank, y = logmean)) +
    xlab("Feature Rank")+
    ylab("Feature Importance Score (Log-Scaled)")+
    {if(indvPermScoresOn==TRUE){
    geom_line(data = permdata2,
              aes(x=featureRank, group=permutation, y = LogfeatureImportance), alpha=.8, col="lightblue")
    }}+
    geom_ribbon(aes(ymin=loglower, ymax=logupper),fill="grey20",alpha=0.6) +
    geom_line() +
    geom_line(aes(x=featureRank, y = logobserved), colour = "gold3") +
    ylim(ylimitmin,ylimitmax) +
    geom_vline(xintercept = which(qdata2$logobserved<qdata2$logupper)[1]-1,color="red") +
    xlim(xlimitmin,xlimitmax)+
    annotate(x=which(qdata2$logobserved<qdata2$logupper)[1]-1,y=+Inf,label=paste0("No. Features above alpha threshold: ",which(qdata2$logobserved<qdata2$logupper)[1]-1),vjust=labelverticaladjust,hjust=labelhorizontaladjust,geom="label") +
    theme_linedraw()+
    NULL
  } else {
      q_data<-quantiledata
      q_data2<-q_data %>% dplyr::filter(mean > 0) %>% dplyr::filter(observed>0)
      perm_data<-permutedvalues
      perm_data2 <- perm_data %>% dplyr::filter(featureRank %in% q_data2$featureRank) %>% dplyr::filter(featureImportance>0)
      ggplot2::ggplot(q_data2, aes(x = featureRank, y = mean)) +
      xlab("Feature Rank")+
      ylab("Feature Importance Score")+
      {if(indvPermScoresOn==TRUE){
        geom_line(data = perm_data2,
                  aes(x=featureRank, group=permutation, y = featureImportance), alpha=.8, col="lightblue")
      }}+
      geom_ribbon(aes(ymin=lower, ymax=upper),fill="grey20",alpha=0.6) +
      geom_line() +
      geom_line(aes(x=featureRank, y = observed), colour = "gold3") +
      ylim(ylimitmin,ylimitmax) +
      geom_vline(xintercept = which(q_data2$observed<q_data2$upper)[1]-1,color="red") +
      xlim(xlimitmin,xlimitmax)+
      annotate(x=which(q_data2$observed<q_data2$upper)[1]-1,y=+Inf,label=paste0("No. Features above alpha threshold: ",which(q_data2$observed<q_data2$upper)[1]-1),vjust=labelverticaladjust,hjust=labelhorizontaladjust,geom="label") +
      theme_linedraw()+
      NULL
  }

}

#' Generate a histogram showing the sum of absolute deviations by count, the measures used to calculate the pi statistics used in the p-value calculation for the set.
#' This function generates a histogram illustrating the sum of absolute deviations in the permuted set vs the true (observed) set. It is a visualization of the data used to calculate the p-value for the entire feature set.
#'
#' @param permutedvalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_permuted_fws function
#' @param quantiledata a tibble containing: featureRanks, mean, lower, upper, and observed as well as logmean, loglower, logupper, logobserved generated by the calculateQuantiles function
#' @return A histogram of count by sum of absolute deviations, showing the differences between the null and observed datasets.
#' @export
piHistogram<-function(permutedvalues,quantiledata){
    d<-permutedvalues
    numberofPermutations<-max(d$permutation)
    d <- d %>%
      mutate(Mean = rep( quantiledata$mean, times = numberofPermutations) ) %>%
      mutate(Dev = featureImportance - Mean)
    d <- d %>% mutate(Mean = rep( quantiledata$mean, times = numberofPermutations) ) %>% mutate(Dev = featureImportance - Mean)
    pi_permuted <- d %>% group_by(permutation) %>% summarise(Sum_abs_deviations = sum(abs(Dev)))
    pi_obs<-sum(abs(quantiledata$observed - quantiledata$mean))
      ggplot(pi_permuted,aes(x = Sum_abs_deviations)) +
      geom_histogram(bins=numberofPermutations) +
      xlab("Sum of Absolute Deviations")+
      ylab("Count")+
      geom_vline(xintercept = pi_obs,color="red") +
      annotate(x=pi_obs,y=+Inf,label=paste0("pi_obs: ",round(pi_obs,2)),vjust=2,hjust=1.2,geom="label") +
      theme_linedraw()+
      NULL
}


#' Generate a plot of the empirical cumulative density function showing the sum of absolute deviations by fraction of data.
#'
#' @param permutedvalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_permuted_fws function
#' @param quantiledata a tibble containing: featureRanks, mean, lower, upper, and observed as well as logmean, loglower, logupper, logobserved generated by the calculateQuantiles function
#' @return A plot of the empirical cumulative density function showing the sum of absolute deviations by fraction of data.
#' @export
piECDF<-function(permutedvalues,quantiledata){
  d<-permutedvalues
  numberofPermutations<-max(d$permutation)
  d1 <- d %>%
    mutate(Mean = rep( quantiledata$mean, times = numberofPermutations) ) %>%
    mutate(Dev = featureImportance - Mean)
  d2 <- d1 %>% mutate(Mean = rep( quantiledata$mean, times = numberofPermutations) ) %>% mutate(Dev = featureImportance - Mean)
  pi_permuted <- d2 %>% group_by(permutation) %>% summarise(Sum_abs_deviations = sum(abs(Dev)))
  pi_obs<-sum(abs(quantiledata$observed - quantiledata$mean))
  ggplot(pi_permuted,aes(x = Sum_abs_deviations)) +
    stat_ecdf(geom = "step")+
    geom_vline(xintercept = pi_obs,color="red") +
    annotate(x=pi_obs,y=+Inf,label=paste0("pi_obs: ",round(pi_obs,2)),vjust=4,hjust=1.1,geom="label") +
    labs(y = "Fraction of Data", x="Sum of Absolute Deviations")+
    theme_linedraw()+
    NULL
}



