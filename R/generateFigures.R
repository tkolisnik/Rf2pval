#' Generate Weight-Rank Plot
#' This function generates a figure which shows the true observed data plotted against the permuted data, by rank. The intersection of the true data with the upper quartile is shown, which we recommend as a significance cutoff.
#' @param truevalues a tibble of featureRanks, feature names, feature weights, log feature weights and permutation # generated by the load_true_fws function
#' @param permutedvalues a tibble of featureRanks, feature names, feature weights, log feature weights and permutation # generated by the load_permuted_fws function
#' @param quantiledata a tibble containing: featureRanks, mean, lower, upper, and observed as well as logmean, loglower, logupper, logobserved generated by the calculateQuantiles function
#' @param xlimitmin a numerical value for the minimum x value in the figure, default is 0
#' @param xlimitmax a numerical value for the maximum x value in the figure, default is 500 (this is effectively the total number of features to include)
#' @param ylimitmin a numerical value for the minimum y value in the figure, default is 0
#' @param ylimitmax a numerical value for the maximum y value in the figure, default is 0.0045, but this will vary largely depending on your dataset, set it larger then narrow down
#' @return A plot of feature weight by feature rank showing the upper quartile intersection which we recommend to use for a cutoff.
#' @export
weightRankPlot<-function(truevalues,permutedvalues,quantiledata,xlimitmin=0,xlimitmax=500,ylimitmin=0,ylimitmax=0.0045){
  pdata<-quantiledata
  wrplot<- pdata %>%
    dplyr::filter(mean > 0) %>%
    ggplot2::ggplot(aes(x = featureRank, y = mean)) +
    xlab("Feature Rank")+
    ylab("Feature Weight")+
    geom_line(data = permutedvalues %>% dplyr::filter(featureWeight > 0),
              aes(x=featureRank, group=permutation, y = featureWeight), alpha=.8, col="lightblue") +
    geom_ribbon(aes(ymin=lower, ymax=upper),fill="grey20",alpha=0.6) +
    geom_line() +
    geom_line(aes(x=featureRank, y = observed), colour = "gold3") +
    scale_y_continuous(limits=c(ylimitmin,ylimitmax)) +
    geom_vline(xintercept = which(pdata$observed<pdata$upper)[1],color="red") +
    xlim(xlimitmin,xlimitmax)+
    annotate(x=which(pdata$observed<pdata$upper)[1],y=+Inf,label=paste0("Intersection with Upper Quartile: ",which(pdata$observed<pdata$upper)[1]),vjust=2,geom="label") +
    NULL
  wrplot
}

#' Generate Log Weight-Rank Plot
#' This function generates a figure which shows the true observed data plotted against the permuted data, by rank. The intersection of the true data with the upper quartile is shown, which we recommend as a significance cutoff.
#' @param truevalues a tibble of featureRanks, feature names, feature weights, log feature weights and permutation # generated by the load_true_fws function
#' @param permutedvalues a tibble of featureRanks, feature names, feature weights, log feature weights and permutation # generated by the load_permuted_fws function
#' @param quantiledata a tibble containing: featureRanks, mean, lower, upper, and observed as well as logmean, loglower, logupper, logobserved generated by the calculateQuantiles function
#' @param xlimitmin a numerical value for the minimum x value in the figure, default is 0
#' @param xlimitmax a numerical value for the maximum x value in the figure, default is 500 (this is effectively the total number of features to include)
#' @param ylimitmin a numerical value for the minimum y value in the figure, default is -10
#' @param ylimitmax a numerical value for the maximum y value in the figure, default is 0, but this will vary largely depending on your dataset, set it larger then narrow down
#' @return A plot of log feature weight by feature rank showing the upper quartile intersection which we recommend to use for a cutoff.
#' @export
logWeightRankPlot<-function(truevalues,permutedvalues,quantiledata,xlimitmin=1,xlimitmax=500,ylimitmin=-10,ylimitmax=0,labelverticaladjust=1.05,labelhorizontaladjust=1.05){
  pdata<-quantiledata
  lwrplot<- pdata %>%
    dplyr::filter(mean > 0) %>%
    ggplot2::ggplot(aes(x = featureRank, y = logmean)) +
    xlab("Feature Rank")+
    ylab("Log Feature Weight")+
    geom_line(data = permutedvalues %>% dplyr::filter(LogfeatureWeight > 0),
              aes(x=featureRank, group=permutation, y = LogfeatureWeight), alpha=.8, col="lightblue") +
    geom_ribbon(aes(ymin=loglower, ymax=logupper),fill="grey20",alpha=0.6) +
    geom_line() +
    geom_line(aes(x=featureRank, y = logobserved), colour = "gold3") +
    scale_y_continuous(limits=c(ylimitmin,ylimitmax)) +
    geom_vline(xintercept = which(pdata$logobserved<pdata$logupper)[1],color="red") +
    xlim(xlimitmin,xlimitmax)+
    annotate(x=which(pdata$logobserved<pdata$logupper)[1],y=+Inf,label=paste0("Intersection with Upper Quartile: ",which(pdata$logobserved<pdata$logupper)[1]),vjust=labelverticaladjust,hjust=labelhorizontaladjust,geom="label") +
    NULL
  lwrplot
}


#' Generate a histogram showing the sum of absolute deviations by count, the measures used to calculate the pi statistics used in the p-value calculation for the set.
#' This function generates a histogram illustrating the sum of absolute deviations in the permuted set vs the true (observed) set. It is a visualization of the data used to calculate the p-value for the entire feature set.
#'
#' @param permutedvalues a tibble of featureRanks, feature names, feature weights, log feature weights and permutation # generated by the load_permuted_fws function
#' @param quantiledata a tibble containing: featureRanks, mean, lower, upper, and observed as well as logmean, loglower, logupper, logobserved generated by the calculateQuantiles function
#' @return A histogram of count by sum of absolute deviations, showing the differences between the null and observed datasets.
#' @export
piHistogram<-function(permutedvalues,quantiledata){
    d<-permutedvalues
    numberofPermutations<-max(d$permutation)+1
    d <- d %>%
      mutate(Mean = rep( quantiledata$mean, times = numberofPermutations) ) %>%
      mutate(Dev = featureWeight - Mean)
    d <- d %>% mutate(Mean = rep( quantiledata$mean, times = numberofPermutations) ) %>% mutate(Dev = featureWeight - Mean)
    pi_permuted <- d %>% group_by(permutation) %>% summarise(Sum_abs_deviations = sum(abs(Dev)))
    pi_obs<-sum(abs(quantiledata$observed - quantiledata$mean))
    outplot<-pi_permuted %>%
      ggplot(aes(x = Sum_abs_deviations)) +
      geom_histogram(bins=numberofPermutations) +
      xlab("Sum of Absolute Deviations")+
      ylab("Count")+
      geom_vline(xintercept = pi_obs,color="red") +
      annotate(x=pi_obs,y=+Inf,label=paste0("pi_obs: ",round(pi_obs,2)),vjust=2,hjust=1.2,geom="label") +
      NULL
    outplot
  }
