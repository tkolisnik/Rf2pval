#' Calculate Quantiles
#' @param truevalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_true_fws function
#' @param permutedvalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_permuted_fws function
#' @param alpha The alpha value upon which to calculate the upper and lower quantiles, default alpha=0.05
#' @return A tibble of quantile data.
#' @export
calculateQuantiles<-function(truevalues,permutedvalues,alpha=0.05){
  print(paste0("Using alpha ",alpha))
  dm <- permutedvalues %>% group_by(featureRank) %>%
  summarise(mean = mean(featureImportance),
            lower = stats::quantile(featureImportance, prob=alpha),
            upper = stats::quantile(featureImportance, prob=1-alpha)) %>%
            mutate(observed = truevalues$featureImportance) %>%
            mutate(logmean=log(mean)) %>%
            mutate(logupper=log(upper)) %>%
            mutate(loglower=log(lower)) %>%
            mutate(logobserved=log(observed))
  return(dm)
}


#' Calculate P value for entire feature set
#' @param permutedvalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_permuted_fws function
#' @param quantiledata a tibble containing: featureRanks, mean, lower, upper, and observed as well as logmean, loglower, logupper, logobserved generated by the calculateQuantiles function
#' @return A dataframe with one column and one row in which contains the proportion-based p-value for the entire feature set.
#' @export
calculatePvalueforSet<-function(permutedvalues,quantiledata){
  d<-permutedvalues
  numberofPermutations<-max(d$permutation)
  d <- d %>% ungroup() %>%
    mutate(Mean = rep( quantiledata$mean, times = numberofPermutations) ) %>%
    mutate(Dev = featureImportance - Mean)
  d <- d %>% mutate(Mean = rep( quantiledata$mean, times = numberofPermutations) ) %>% mutate(Dev = featureImportance - Mean)
  pi_permuted <- d %>% group_by(permutation) %>% summarise(Sum_abs_deviations = sum(abs(Dev)))
  pi_obs <- sum(abs(quantiledata$observed - quantiledata$mean))
# p-value for the pi statistic (sum of absolute deviations from rank mean weights)
  pvalpi<- (1 - mean(pi_permuted$Sum_abs_deviations < pi_obs))
  outdat<-data.frame("Proportion_based_P-value_for_entire_feature_set"=pvalpi)
  outdat
  print(paste0("The proportion based p-value for the entire feature set:",outdat[,1]))
}

#' Calculate P value for each rank
#' @param truevalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_true_fws function
#' @param permutedvalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_permuted_fws function
#' @param quantiledata a tibble containing: featureRanks, mean, lower, upper, and observed as well as logmean, loglower, logupper, logobserved generated by the calculateQuantiles function
#' @param alpha The alpha value for p-value calculation, default = 0.05
#' @return A dataframe of featureRanks, proportions and pvalues
#' @export
calculatePvalueforRank<-function(truevalues,permutedvalues,quantiledata,alpha=0.05){
  fweights <- stats::aggregate(featureImportance~featureRank, permutedvalues, 'c')
  fweights2 <- fweights %>% mutate(observedmean=truevalues$featureImportance)
  fweights3 <- fweights2 %>% mutate(proportion=rowSums(fweights2$featureImportance > fweights2$observedmean,na.rm = TRUE)) %>% mutate(pvalue=(proportion/100))
  fweightPvals <- fweights3[,c("featureRank","proportion","pvalue")]
  fweightPvals2 <-left_join(truevalues,fweightPvals)
  fweightPvals3 <-  fweightPvals2[0:(which(fweightPvals2$pvalue>=alpha)[1]-1),]#Ensures we only get a one-tailed representation
  return(fweightPvals3)
}

#' Calculate P value for FWER (used in calculateFWERforRank Function)
#' @param truevalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_true_fws function
#' @param permutedvalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_permuted_fws function
#' @param quantiledata a tibble containing: featureRanks, mean, lower, upper, and observed as well as logmean, loglower, logupper, logobserved generated by the calculateQuantiles function
#' @param alpha The alpha value for p-value calculation, default = 0.05
#' @return A dataframe of featureRanks, proportions and pvalues
#' @export
calculatePvalueforFWER<-function(truevalues,permutedvalues,quantiledata,alpha=0.05){
  fweights <- stats::aggregate(featureImportance~featureRank, permutedvalues, 'c')
  fweights2 <- fweights %>% mutate(observedmean=truevalues$featureImportance)
  fweights3 <- fweights2 %>% mutate(proportion=rowSums(fweights2$featureImportance > fweights2$observedmean,na.rm = TRUE)) %>% mutate(pvalue=(proportion/100))
  fweightPvals <- fweights3[,c("featureRank","proportion","pvalue")]
  fweightPvals2 <-left_join(truevalues,fweightPvals)
  fweightPvals2[(which(fweightPvals2$pvalue>=alpha)[1]):dim(fweightPvals2)[1],"pvalue"]<-1 #Ensures we only get a one-tailed representation
  return(fweightPvals2)
}



#' Calculate Family-Wise Error Rate values for each rank
#' @param truevalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_true_fws function
#' @param permutedvalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_permuted_fws function
#' @param quantiledata a tibble containing: featureRanks, mean, lower, upper, and observed as well as logmean, loglower, logupper, logobserved generated by the calculateQuantiles function
#' @param alpha The alpha value for p-value calculation, default = 0.05
#' @return A dataframe containing FWER for each permutation
#' @export
calculateFWERforRank<-function(truevalues,permutedvalues,quantiledata,alpha=0.05){
 permutations<-max(permutedvalues$permutation)
 fwerList <- list()

 for(i in 1:permutations){
   p_val_loop<-subset(permutedvalues,permutedvalues$permutation==i)
   permutedvalues2<-subset(permutedvalues,permutation!=i)
   p_valfwer<-calculatePvalueforFDR(p_val_loop,permutedvalues,quantiledata)
   fwerList[[i]]<-p_valfwer
 }

 allDat<- do.call(rbind,fwerList)
 allDat2<- allDat %>% dplyr::group_by(permutation) %>% mutate(fwer_tf=(pvalue<alpha)) %>% tally(fwer_tf)
 allDat3<-sum(allDat2$n>0)/permutations
 allDat4<-paste0("The Family-Wise Error Rate is: ", allDat3)
 return(allDat4)
}


