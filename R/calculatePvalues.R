#' Calculate Quantiles
#' @param truevalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_true_fws function
#' @param permutedvalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_permuted_fws function
#' @param alpha The alpha value upon which to calculate the upper and lower quantiles, default alpha=0.05
#' @return A tibble of quantile data.
#' @export
calculateQuantiles<-function(truevalues,permutedvalues,alpha=0.05){
  print(paste0("Using alpha ",alpha))
  dm <- permutedvalues %>% group_by(featureRank) %>%
  summarise(mean = mean(featureImportance),
            lower = stats::quantile(featureImportance, prob=alpha),
            upper = stats::quantile(featureImportance, prob=1-alpha)) %>%
            mutate(observed = truevalues$featureImportance) %>%
            mutate(logmean=log(mean)) %>%
            mutate(logupper=log(upper)) %>%
            mutate(loglower=log(lower)) %>%
            mutate(logobserved=log(observed))
  return(dm)
}


#' Calculate P value for entire feature set
#' @param permutedvalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_permuted_fws function
#' @param quantiledata a tibble containing: featureRanks, mean, lower, upper, and observed as well as logmean, loglower, logupper, logobserved generated by the calculateQuantiles function
#' @return A dataframe with one column and one row in which contains the proportion-based p-value for the entire feature set.
#' @export
calculatePvalueforSet<-function(permutedvalues,quantiledata){
  d<-permutedvalues
  numberofPermutations<-max(d$permutation)
  d <- d %>% ungroup() %>%
    mutate(Mean = rep( quantiledata$mean, times = numberofPermutations) ) %>%
    mutate(Dev = featureImportance - Mean)
  d <- d %>% mutate(Mean = rep( quantiledata$mean, times = numberofPermutations) ) %>% mutate(Dev = featureImportance - Mean)
  pi_permuted <- d %>% group_by(permutation) %>% summarise(Sum_abs_deviations = sum(abs(Dev)))
  pi_obs <- sum(abs(quantiledata$observed - quantiledata$mean))
# p-value for the pi statistic (sum of absolute deviations from rank mean weights)
  pvalpi<- (1 - mean(pi_permuted$Sum_abs_deviations < pi_obs))
  outdat<-data.frame("Proportion_based_P-value_for_entire_feature_set"=pvalpi)
  outdat
  print(paste0("The proportion based p-value for the entire feature set:",outdat[,1]))
}

#' Calculate P value for each rank
#' @param truevalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_true_fws function
#' @param permutedvalues a tibble of featureRanks, feature names, feature importance scores, log feature importance scores and permutation # generated by the load_permuted_fws function
#' @param quantiledata a tibble containing: featureRanks, mean, lower, upper, and observed as well as logmean, loglower, logupper, logobserved generated by the calculateQuantiles function
#' @return A dataframe of featureRanks, proportions and pvalues
#' @export
calculatePvalueforRank<-function(truevalues,permutedvalues,quantiledata){
  fweights <- stats::aggregate(featureImportance~featureRank, permutedvalues, 'c')
  fweights2 <- fweights %>% mutate(observedmean=truevalues$featureImportance)
  fweights3 <- fweights2 %>% mutate(proportion=rowSums(fweights2$featureImportance > fweights2$observedmean,na.rm = TRUE)) %>% mutate(pvalue=(proportion/100))
  fweightPvals <- fweights3[,c("featureRank","proportion","pvalue")]
  fweightPvals2 <-left_join(truevalues,fweightPvals)
  return(fweightPvals2)

}


